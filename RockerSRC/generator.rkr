//-----------------------------------------------------------------------------
//  ROCKER GENERATOR
//  MIT License
//  Copyright (c) 2024 Paul Passeron
//-----------------------------------------------------------------------------

include "RockerSRC/name_table.rkr"
include "RockerSRC/stdlib.rkr"

rec gen => {
    f: file,
    table: nt
}

let new_gen(filename: string): gen => {
    let res: gen => {
        f => open_file(filename, WRITE_MODE),
        table => new_nt(),
    };
    return res;
}

let kill_generator(g: gen): void => {
    close_file(g::f);
}

let generate_type(g: gen, a: ast): void => {
    let type: ast_type => a::Data::data_type;
    if type::is_array then pfile(g::f, "__internal_dynamic_array_t");
    else pfile(g::f, type::name::Lexeme);
}

let generate_gen_type_fun(g: gen, funcall: ast_funcall, suffixe: string): void => {
    let args: ast [] => funcall::args;
    // skipping error catching because this will be done by the typechecker
    let arr_ast: ast => get(args, 0);
    let arr_name: string => arr_ast::Data::data_identifier::id::Lexeme;
    // getting the type of the array (for the moment you have to bind
    // it to a variable, even if it is an argument to the function
    let ref: ast => get_ref(arr_name, g::table);
    if ref::Tag != tag_vardef then
        print("Arrays must be declared as variables !\n");
        exit(1);
    generate_type(g, ref::Data::data_vardef::type);
    print(suffixe);
    pfile(g::f,"(");
    generate_expression(g, get(args, 0));
    pfile(g::f, ", ");
    generate_expression(g, get(args, 1));
    pfile(g::f, ")");
}

let generate_append(g: gen, funcall: ast_funcall): void => {
   generate_gen_type_fun(g, funcall, "_get_elem");
}

let generate_get(g: gen, funcall: ast_funcall): void => {
   generate_gen_type_fun(g, funcall, "_get_elem");
}

let generate_set(g: gen, funcall: ast_funcall): void => {
   generate_gen_type_fun(g, funcall, "_set_elem");
}

let generate_funcall(g: gen, fun: ast): void => {
    let funcall: ast_funcall => fun::Data::data_funcall;
    if str_eq(funcall::name::Lexeme, "append") then
        generate_append(g, funcall);
    else if str_eq(funcall::name::Lexeme, "get") then
        generate_get(g, funcall);
    else if str_eq(funcall::name::Lexeme, "set") then
        generate_set(g, funcall);
    else {
        pfile(g::f, funcall::name::Lexeme);
        pfile(g::f, "(");
        let args: ast [] => funcall::args;
        loop i: 0 -> get_length(args) - 1 => {
            if i > 0 then pfile(g::f, ", ");
            generate_expression(g, get(args, i));
        }
        pfile(g::f, ")");
    }    
}

let get_lit_str_length(s: string): int => {
    let length: int => 0;
    loop i: 0 -> get_string_length(s) - 1 => {
        if get_nth_char(s, i) = '\\' then {
            i => i + 1;
            let c: char => get_nth_char(s, i);
            if c = 'n' || c = 't'  || c = '\\' ||
              c = '\"' || c = '\'' || c = 'r' then
                length => length + 1; 
            else length => length + 2;
        }
        else length => length + 1;
    }
    return length;
}

let generate_op(g: gen, expr: ast): void => {
    let op: ast_op => expr::Data::data_op;
    generate_expression(g, op::left);
    if op::op = TOK_EQUAL then
        pfile(g::f, "==");
    else
        pfile(g::f, lexeme_of_type(op::op));
    generate_expression(g, op::right);
}

let generate_if_statement(g: gen, stmt: ast): void => {
    let ifstmt: ast_ifstmt => stmt::Data::data_ifstmt;
    pfile(g::f, "if (");
    generate_expression(g, ifstmt::expr);
    pfile(g::f, ")\n");
    generate_statement(g, ifstmt::body);
    if ifstmt::elsestmt != NULL then{
        pfile(g::f, "else\n");
        generate_statement(g, ifstmt::elsestmt);
    }
}

let generate_array_funcs(g: gen, type_name: string): void => {
        pfile(g::f, "__internal_dynamic_array_t ");
        pfile(g::f, type_name);
        pfile(g::f, "_make_array(void) {\n");
        pfile(g::f, "return __internal_make_array(sizeof(");
        pfile(g::f, type_name);
        pfile(g::f, "));\n");
        pfile(g::f, "}\n\n");
        pfile(g::f, " void ");
        pfile(g::f, type_name);
        pfile(g::f, "_push_array(__internal_dynamic_array_t arr, ");
        pfile(g::f, type_name);
        pfile(g::f," elem) {\n");
        pfile(g::f, "  __internal_push_array(arr, &elem);\n");
        pfile(g::f, "}\n\n");
        pfile(g::f, type_name);
        pfile(g::f, " ");
        pfile(g::f, type_name);
        pfile(g::f, "_pop_array(__internal_dynamic_array_t arr) {\n ");
        pfile(g::f, type_name);
        pfile(g::f, " *res = __internal_pop_array(arr);\n");
        pfile(g::f, "  return *res;\n");
        pfile(g::f, "}\n\n");
        pfile(g::f, type_name);
        pfile(g::f, " ");
        pfile(g::f, type_name);
        pfile(g::f, "_get_elem(__internal_dynamic_array_t arr, size_t index) {\n ");
        pfile(g::f, type_name);
        pfile(g::f, " *res = __internal_get_elem(arr, index);\n");
        pfile(g::f,"  if (res == NULL){ printf(\"NULL ELEMENT IN ");
        pfile(g::f, type_name);
        pfile(g::f, "_get_elem\"); exit(1);}");
        pfile(g::f, "  return *res;\n");
        pfile(g::f, "}\n\n");
        pfile(g::f, "void ");
        pfile(g::f, type_name);
        pfile(g::f, "_set_elem(__internal_dynamic_array_t arr, size_t index, ");
        pfile(g::f ,type_name);
        pfile(g::f, " elem) {\n");
        pfile(g::f, "  __internal_set_elem(arr, index, &elem);\n");
        pfile(g::f, "}\n\n");
        pfile(g::f,"void ");
        pfile(g::f, type_name);
        pfile(g::f, "_insert(__internal_dynamic_array_t arr, size_t index, ");
        pfile(g::f, type_name);
        pfile(g::f, " elem) {\n");
        pfile(g::f, "  __internal_insert(arr, index, &elem);\n");
        pfile(g::f, "}\n\n");
}

let generate_loop(g: gen, loop_ast: ast): void => {
    let l: ast_loop => loop_ast::Data::data_loop;
    new_nt_scope(g::table);
    push_nt(g::table, l::variable::Lexeme, NT_VAR, loop_ast);
    pfile(g::f, "for(int ");
    pfile(g::f, l::variable::Lexeme);
    pfile(g::f, " =");
    generate_expression(g, l::start);
    pfile(g::f, "; ");
    pfile(g::f, l::variable::Lexeme);
    pfile(g::f, " <= ");
    generate_expression(g, l::end);
    pfile(g::f, "; ");
    pfile(g::f, l::variable::Lexeme);
    pfile(g::f, "++)");
    generate_statement(g, l::statement);
    end_nt_scope(g::table);
}

let generate_sub_as_expression(g: gen, expr: ast): void => {
    let sub: ast_sub => expr::Data::data_sub;
    let path: token [] => sub::path;
    loop i: 0 -> get_length(path) - 1 => {
        let tok: token => get(path, i);
        pfile(g::f, tok::Lexeme);
        pfile(g::f, "->");
        generate_expression(g, sub::expr);
    }
}

let generate_while_loop(g: gen, l: ast): void => {
    let while_loop: ast_while_loop => l::Data::data_while_loop;
    pfile(g::f, "while (");
    generate_expression(g, while_loop::condition);
    pfile(g::f, ")\n");
    generate_statement(g, while_loop::statement);
}

let generate_enum_tdef(g: gen, expr: ast): void => {
    let enum_tdef: ast_enum_tdef => expr::Data::data_enum_tdef;
    pfile(g::f, "enum ");
    pfile(g::f, enum_tdef::name::Lexeme);
    pfile(g::f, " {\n");
    let items: token [] => enum_tdef::items;  
    loop i: 0 -> get_length(items) - 1 => {
        if i > 0 then pfile(g::f, ",\n");
        let tok: token => get(items, i);
        pfile(g::f, tok::Lexeme);
    }
    pfile(g::f, "\n}:\n");
}

let generate_expression(g: gen, expr: ast): void => {
    if expr::Tag = tag_literal then {
        let tok: token => expr::Data::data_literal::lit;
        if tok::Type != TOK_STR_LIT then
            pfile(g::f, tok::Lexeme);
        else {
            pfile(g::f, "new_string((string){.data = ");
            pfile(g::f, tok::Lexeme);
            pfile(g::f, ", .length = ");
            pfile(g::f, string_of_int(get_lit_str_length(tok::Lexeme)-2));
            pfile(g::f, "})");
        }
    } else if expr::Tag = tag_identifier then 
        // for the moment we don't perform any checks
        pfile(g::f, expr::Data::data_identifier::id::Lexeme); 
    else if expr::Tag = tag_funcall then
        generate_funcall(g, expr);
    else if expr::Tag = tag_op then
        generate_op(g, expr);
    else if expr::Tag = tag_ifstmt then
        generate_if_statement(g, expr);
    else if expr::Tag = tag_compound then
        generate_compound(g, expr);
    else if expr::Tag = tag_loop then
        generate_loop(g, expr);
    else if expr::Tag = tag_sub then
        generate_sub_as_expression(g, expr);
    else if expr::Tag = tag_assign then
        generate_assign(g, expr);
    else if expr::Tag = tag_while_loop then
        generate_while_loop(g, expr);
    else {
        print("Could not generate expression !\n");
        print_int(expr::Tag);
        print("th tag is not implemented yet !\n");
        compiler_assert(false, "TODO\n");
    }
}


let generate_assign(g: gen, expr: ast): void => {
    let assign: ast_assign => expr::Data::data_assign;
    generate_expression(g, assign::target);
    pfile(g::f, " = ");
    generate_expression(g, assign::expr);
}


let generate_vardef(g: gen, var: ast): void => {
    let vardef: ast_vardef => var::Data::data_vardef;
    push_nt(g::table, vardef::name::Lexeme, NT_VAR, var);
    let type_name: string =>
        vardef::type::Data::data_type::name::Lexeme;
    if vardef::type::Data::data_type::is_array then {
        compiler_assert(false, "TODO\n");
        print(type_name);
    }
        compiler_assert(false, "TODO\n");
}

let generate_compound(g: gen, expr: ast): void => {
    implemented("generate_compound");
}


let generate_sub(g: gen, a: ast_sub, is_rec: boolean): void => {
    // This will have to change anyway
    implemented("generate_sub");
}

let generate_statement(g: gen, a: ast): void => {
    implemented("generate_statement");
}