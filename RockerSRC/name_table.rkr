//-----------------------------------------------------------------------------
//  ROCKER NAME TABLE
//  MIT License
//  Copyright (c) 2024 Paul Passeron
//-----------------------------------------------------------------------------


enum nt_kind => {
    tdef,
    fdef,
    vdef,
}

rec constructor_spec => {
    name: string,
    type: type_spec,
}

rec type_spec => {
    base_type: string,
    arrays: int,
    is_builtin: boolean,
    tdef_kind: tdef_type,
    constructors: constructor_spec [],
}


rec nt_fun => {
    ret_type: type_spec,
    args: type_spec [],
}

rec nt_var => {
    type: type_spec,
}

rec nt_elem => {
    Tag: nt_kind,
    name: string,
    scope: int,
    tdef: type_spec,
    fun: nt_fun,
    var: nt_var,
}

rec nt => {
    elems: nt_elem [],
    scope: int
}

let get_ref(name: string, table: nt):nt_elem => {
    let elems: nt_elem [] => table::elems;
    let max_scope: int => 0-1;
    let res: nt_elem => NULL;
    loop i: 0 -> get_length(elems) - 1 => {
        let elem: nt_elem => get(elems, i);
        if str_eq(elem::name, name) && max_scope < elem::scope then {
            if elem::Tag = tdef then return elem;
            max_scope => elem::scope;
            res => elem;
        }
    }
    return res;
}

let new_nt(): nt => {
    let elems: nt_elem [] => [];
    let res: nt => {
        elems => elems,
        scope => 0,
    };
    return res;
}

let new_nt_scope(table: nt): void => {
    table::scope => table::scope + 1;
}

let end_nt_scope(table: nt): void => {
    let elems: nt_elem [] => table::elems;
    let i: int => get_length(elems) - 1;
    let break_cond: boolean => false;
    while i >= 0 && break_cond = false do {
        let elem: nt_elem => get(elems, i);
        if elem::scope < table::scope then
            break_cond => true;
        else 
            pop(elems);
        i => i - 1;
    }
}

let push_nt(table: nt, name: string, elem: nt_elem): void => {
    let elems: nt_elem [] => table::elems;
    let res: nt_elem => {
        Tag => elem::Tag,
        name => elem::name,
        tdef => elem::tdef,
        fun => elem::fun,
        var => elem::var,
    };
    res::scope => table::scope;
    append(elems, res);
}

let get_builtin_type(name: string): type_spec => {
    let res: type_spec => {
        base_type => name,
        arrays => 0,
        is_builtin => true,
        tdef_kind => TDEF_BUILTIN, 
        constructors => NULL,
    };
    return res;
}

let get_nt_fun(fundef: ast_fundef): nt_elem => {
    let nt_args: type_spec [] => [];
    let types: ast [] => fundef::types;
    loop i: 0 -> get_length(types) - 1 =>
        append(nt_args, nt_type_of_ast(get(types, i)));
    let fundef_elem: nt_fun => {
        ret_type => nt_type_of_ast(fundef::ret_type),
        args => nt_args
    };
    let elem: nt_elem => {
        Tag => fdef,
        name => fundef::name::Lexeme,
        fun => fundef_elem
    };
    return elem;
}

let nt_builtin_vardef(name: string, type: string): nt_elem => {
     let elem_var: nt_var => {
        type => get_builtin_type(type)
    };
    let elem: nt_elem => {
        Tag => vdef,
        name => name,
        var => elem_var
    };
    return elem;
}

let get_nt_var(vardef: ast_vardef): nt_elem => {
    let elem_var: nt_var => {
        type => nt_type_of_ast(vardef::type)
    };
    let elem: nt_elem => {
        Tag => vdef,
        name => vardef::name::Lexeme,
        var => elem_var
    };
    return elem;
}

let nt_type_of_ast(a: ast): type_spec => {
    let type: ast_type => a::Data::data_type;
    let res: type_spec => {
        base_type => type::name::Lexeme,
        is_builtin =>  is_builtin_typename(type::name::Lexeme),
        tdef_kind =>TDEF_BUILTIN,
        constructors => NULL,
    };
    return res;
}


let get_builtin_type_tdef(name: string): nt_elem => {
    let elem: nt_elem => {
        Tag => tdef,
        name => name,
        tdef => get_builtin_type(name),
    };
    return elem;
}

let setup_name_table(table: nt): void => {
    // builtin types
    push_nt(table, "int", get_builtin_type_tdef("int"));
    push_nt(table, "boolean", get_builtin_type_tdef("boolean"));
    push_nt(table, "char", get_builtin_type_tdef("char"));
    push_nt(table, "string", get_builtin_type_tdef("string"));
    push_nt(table, "void", get_builtin_type_tdef("void"));
    push_nt(table, "null_type", get_builtin_type_tdef("null_type"));
    push_nt(table, "array", get_builtin_type_tdef("array"));


    // builtin literals
    push_nt(table, "true", nt_builtin_vardef("true", "boolean"));
    push_nt(table, "false", nt_builtin_vardef("false", "boolean"));
    push_nt(table, "NULL", nt_builtin_vardef("NULL", "null_type"));

    // builtin functions


}