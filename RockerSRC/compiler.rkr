//-----------------------------------------------------------------------------
//  ROCKER COMPILER
//  MIT License
//  Copyright (c) 2024 Paul Passeron
//-----------------------------------------------------------------------------

// Compiler of Rocker programming 
// language written in itself !


//-----------------------------------------------------------------------------
// ENUMERATION PLACEHOLDERS
//-----------------------------------------------------------------------------

let counter: int => 0;

let incr_counter(): int => {
    counter => counter + 1;
    return counter;
}

let reset_counter(): int => {
    counter => 0;
    return counter;
}
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// TOKEN FUNCTIONS
//-----------------------------------------------------------------------------

let TOK_IDENTIFIER: int => 0;
let TOK_CHR_LIT: int => 0;
let TOK_STR_LIT: int => 0;
let TOK_NUM_LIT: int => 0;
let TOK_LET: int => 0;
let TOK_COLON: int => 0;
let TOK_COMMA: int => 0;
let TOK_SMALL_ARROW: int => 0;
let TOK_BIG_ARROW: int => 0;
let TOK_OPEN_BRACE: int => 0;
let TOK_CLOSE_BRACE: int => 0;
let TOK_OPEN_PAREN: int => 0;
let TOK_CLOSE_PAREN: int => 0;
let TOK_IF: int => 0;
let TOK_THEN: int => 0;
let TOK_ELSE: int => 0;
let TOK_REC: int => 0;
let TOK_PRO: int => 0;
let TOK_MATCH: int => 0;
let TOK_RETURN: int => 0;
let TOK_STAR: int => 0;
let TOK_MINUS: int => 0;
let TOK_PLUS: int => 0;
let TOK_DIV: int => 0;
let TOK_MODULO: int => 0;
let TOK_LOG_OR: int => 0;
let TOK_LOG_AND: int => 0;
let TOK_BIT_OR: int => 0;
let TOK_BIT_XOR: int => 0;
let TOK_BIT_AND: int => 0;
let TOK_LSSR: int => 0;
let TOK_LSSR_EQ: int => 0;
let TOK_GRTR: int => 0;
let TOK_GRTR_EQ: int => 0;
let TOK_EQUAL: int => 0;
let TOK_DIFF: int => 0;
let TOK_WILDCARD: int => 0;
let TOK_SUB: int => 0;
let TOK_SEMICOL: int => 0;
let TOK_LOOP: int => 0;
let TOK_COUNT: int => 0;


rec token => {
    Type: int,
    Lexeme: string,
    Col: int,
    Line: int,
    Filename: string 
}

let init_types(): void => {
    TOK_IDENTIFIER => reset_counter();
    TOK_CHR_LIT => incr_counter();
    TOK_STR_LIT => incr_counter();
    TOK_NUM_LIT => incr_counter();
    TOK_LET => incr_counter();
    TOK_COLON => incr_counter();
    TOK_COMMA => incr_counter();
    TOK_SMALL_ARROW => incr_counter();
    TOK_BIG_ARROW => incr_counter();
    TOK_OPEN_BRACE => incr_counter();
    TOK_CLOSE_BRACE => incr_counter();
    TOK_OPEN_PAREN => incr_counter();
    TOK_CLOSE_PAREN => incr_counter();
    TOK_IF => incr_counter();
    TOK_THEN => incr_counter();
    TOK_ELSE => incr_counter();
    TOK_REC => incr_counter();
    TOK_PRO => incr_counter();
    TOK_MATCH => incr_counter();
    TOK_RETURN => incr_counter();
    TOK_STAR => incr_counter();
    TOK_MINUS => incr_counter();
    TOK_PLUS => incr_counter();
    TOK_DIV => incr_counter();
    TOK_MODULO => incr_counter();
    TOK_LOG_OR => incr_counter();
    TOK_LOG_AND => incr_counter();
    TOK_BIT_OR => incr_counter();
    TOK_BIT_XOR => incr_counter();
    TOK_BIT_AND => incr_counter();
    TOK_LSSR => incr_counter();
    TOK_LSSR_EQ => incr_counter();
    TOK_GRTR => incr_counter();
    TOK_GRTR_EQ => incr_counter();
    TOK_EQUAL => incr_counter();
    TOK_DIFF => incr_counter();
    TOK_WILDCARD => incr_counter();
    TOK_SUB => incr_counter();
    TOK_SEMICOL => incr_counter();
    TOK_LOOP => incr_counter();
    TOK_COUNT => incr_counter();
}

let lexeme_of_type(type: int): string => {
         if type = TOK_IDENTIFIER  then return "TOK_IDENTIFIER";
    else if type = TOK_CHR_LIT     then return "TOK_CHR_LIT";
    else if type = TOK_STR_LIT     then return "TOK_STR_LIT";
    else if type = TOK_NUM_LIT     then return "TOK_NUM_LIT";
    else if type = TOK_LET         then return "TOK_LET";
    else if type = TOK_COLON       then return "TOK_COLON";
    else if type = TOK_COMMA       then return "TOK_COMMA";
    else if type = TOK_SMALL_ARROW then return "TOK_SMALL_ARROW";
    else if type = TOK_BIG_ARROW   then return "TOK_BIG_ARROW";
    else if type = TOK_OPEN_BRACE  then return "TOK_OPEN_BRACE";
    else if type = TOK_CLOSE_BRACE then return "TOK_CLOSE_BRACE";
    else if type = TOK_OPEN_PAREN  then return "TOK_OPEN_PAREN";
    else if type = TOK_CLOSE_PAREN then return "TOK_CLOSE_PAREN";
    else if type = TOK_IF          then return "TOK_IF";
    else if type = TOK_THEN        then return "TOK_THEN";
    else if type = TOK_ELSE        then return "TOK_ELSE";
    else if type = TOK_REC         then return "TOK_REC";
    else if type = TOK_PRO         then return "TOK_PRO";
    else if type = TOK_MATCH       then return "TOK_MATCH";
    else if type = TOK_RETURN      then return "TOK_RETURN";
    else if type = TOK_STAR        then return "TOK_STAR";
    else if type = TOK_MINUS       then return "TOK_MINUS";
    else if type = TOK_PLUS        then return "TOK_PLUS";
    else if type = TOK_DIV         then return "TOK_DIV";
    else if type = TOK_MODULO      then return "TOK_MODULO";
    else if type = TOK_LOG_OR      then return "TOK_LOG_OR";
    else if type = TOK_LOG_AND     then return "TOK_LOG_AND";
    else if type = TOK_BIT_OR      then return "TOK_BIT_OR";
    else if type = TOK_BIT_XOR     then return "TOK_BIT_XOR";
    else if type = TOK_BIT_AND     then return "TOK_BIT_AND";
    else if type = TOK_LSSR        then return "TOK_LSSR";
    else if type = TOK_LSSR_EQ     then return "TOK_LSSR_EQ";
    else if type = TOK_GRTR        then return "TOK_GRTR";
    else if type = TOK_GRTR_EQ     then return "TOK_GRTR_EQ";
    else if type = TOK_EQUAL       then return "TOK_EQUAL";
    else if type = TOK_DIFF        then return "TOK_DIFF";
    else if type = TOK_WILDCARD    then return "TOK_WILDCARD";
    else if type = TOK_SUB         then return "TOK_SUB";
    else if type = TOK_SEMICOL     then return "TOK_SEMICOL";
    else if type = TOK_LOOP        then return "TOK_LOOP";
    else                                  return "ERROR";
}

let is_type_keyword(type: int): boolean => {
    if type = TOK_MATCH then return true; 
    if type = TOK_PRO then return true; 
    if type = TOK_REC then return true; 
    if type = TOK_WILDCARD then return true; 
    if type = TOK_RETURN then return true; 
    if type = TOK_SUB then return true; 
    if type = TOK_LET then return true; 
    if type = TOK_IF then return true; 
    if type = TOK_THEN then return true; 
    if type = TOK_ELSE then return true; 
    if type = TOK_LOOP then return true; 
    return false;
}

let is_type_operator(type: int): boolean => {
    if type = TOK_STAR then return true;
    if type = TOK_MINUS then return true;
    if type = TOK_PLUS then return true;
    if type = TOK_DIV then return true;
    if type = TOK_MODULO then return true;
    if type = TOK_LOG_OR then return true;
    if type = TOK_LOG_AND then return true;
    if type = TOK_BIT_OR then return true;
    if type = TOK_BIT_XOR then return true;
    if type = TOK_BIT_AND then return true;
    if type = TOK_LSSR then return true;
    if type = TOK_LSSR_EQ then return true;
    if type = TOK_GRTR then return true;
    if type = TOK_GRTR_EQ then return true;
    if type = TOK_EQUAL then return true;
    if type = TOK_DIFF then return true;
    return false;

}


//-----------------------------------------------------------------------------



//-----------------------------------------------------------------------------
// TOKEN LIST FUNCTIONS
//-----------------------------------------------------------------------------
rec token_list => {
    Head: token,
    Tail: token_list
}


let append_token(l: token_list, t: token): token_list => {
    let res : token_list => {
        Head => t,
        Tail => l
    };
    return res;
}


let get_nth_token_aux(l: token_list, n: int): token => {
    if l = NULL then {
        print("Index out of range: Cannot access token !\n");
        exit(1);
    }
    if n = 0 then return l::Head;
    return get_nth_token_aux(l::Tail, n-1);
}


let get_list_length(l: token_list): int => {
    if l = NULL then return 0;
    return 1 + get_list_length(l::Tail);
}

let get_nth_token(l: token_list, n: int) : token => {
    return get_nth_token_aux(l, get_list_length(l) - n - 1);
}

let print_list_types(l: token_list) : void => {
    let len: int => get_list_length(l);
    loop i: 0 -> len-1 => {
        let tok: token => get_nth_token(l, i);
        print("-> ");
        print(lexeme_of_type(tok::Type));
        print("\n");
    }
}
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// LEXER FUNCTIONS
//-----------------------------------------------------------------------------


rec lexer => {
    Data: string,
    Cursor: int,
    Col: int,
    Line: int,
    Filename: string,
    Toks: token_list
}


let new_lexer(filename: string): lexer => {
    let data: string => read_file(filename);
    let res: lexer => {
        Data => data,
        Cursor => 0,
        Col => 1,
        Line => 1,
        Filename => filename,
        Toks => NULL
    }; return res;
}

let is_lexer_done(l: lexer): boolean => {
    implemented("is_lexer_done");
}

let step_lexer(l: lexer): void => {
   implemented("step_lexer");
}

let lex_program(l: lexer): void => {
    implemented("lex_program");
}

//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// UTILS FUNCTIONS
//-----------------------------------------------------------------------------

let implemented(s: string): void => {
    print("TODO: ");
    print(s);
    print(" is not yet implemented\n");
    exit(1);
}


let compiler_assert(b: boolean): void => {
    if b = 0 then {
        print("Assertion failed\n");
        exit(1);
    }
}

let create_lexeme(src: string, offset: int,  length: int): string => {
    let res: string => "";
    loop i: 0 -> length - 1 => {
        let c: char => get_nth_char(src, offset + i);
        res => append_string(res, c);
    }
    return res;
}

let is_whitespace(c: char): boolean => {
    if c = ' ' then return true;
    if c = '\n' then return true;
    if c = '\t' then return true;
}

let is_delimeter(c: char): boolean => {
    let delimeters: string => "><;,:-+*/%&|!=(){}^ \n\'\"";
    let len: int => get_string_length(delimeters);
    loop i: 0 -> len - 1 => {
        if get_nth_char(delimeters, i) = c then 
            return true;
    }
    return false;
}

//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// FILE HANDLING
//-----------------------------------------------------------------------------

rec file => {
    Filename: string,
    Data: string,
}

let READ_MODE: int => 0;
let WRITE_MODE: int => 0;

let init_file_modes(): void => {
    READ_MODE => reset_counter();
    WRITE_MODE => incr_counter();
}

let open_file(filename: string, mode: int): file => {
    let res: file => {
        Filename => filename,
        Data => ""
    }; 
    if mode = READ_MODE then  
        res::Data => read_file(filename);
    return res;
}

let close_file(f: file): void => {
    write_string_to_file(f::Data, f::Filename);
    f::Data => "";
    f::Filename => "";
}

let print_to_file(f: file, s: string): void => {
    f::Data => concat_string(f::Data, s);
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MAIN FUNCTION
//-----------------------------------------------------------------------------

let init(): void => {
    init_types();
    init_file_modes();
}


let main(): int => {
    init();
    let l: lexer => new_lexer("examples/fact.rkr");
    lex_program(l);
    return 0;
}

//-----------------------------------------------------------------------------
