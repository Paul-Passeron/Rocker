//-----------------------------------------------------------------------------
//  ROCKER COMPILER
//  MIT License
//  Copyright (c) 2024 Paul Passeron
//-----------------------------------------------------------------------------

// Compiler of Rocker programming 
// language written in itself !


//-----------------------------------------------------------------------------
// ENUMERATION PLACEHOLDERS
//-----------------------------------------------------------------------------

let counter: int => 0;

let incr_counter(): int => {
    counter => counter + 1;
    return counter;
}

let set_counter(i: int): int => {
    counter => i;
    return counter;
}

let reset_counter(): int => {
    counter => 0;
    return counter;
}



//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// TOKEN FUNCTIONS
//-----------------------------------------------------------------------------

let TOK_IDENTIFIER: int => 0;
let TOK_CHR_LIT: int => 0;
let TOK_STR_LIT: int => 0;
let TOK_NUM_LIT: int => 0;
let TOK_LET: int => 0;
let TOK_COLON: int => 0;
let TOK_COMMA: int => 0;
let TOK_SMALL_ARROW: int => 0;
let TOK_BIG_ARROW: int => 0;
let TOK_OPEN_BRACE: int => 0;
let TOK_CLOSE_BRACE: int => 0;
let TOK_OPEN_PAREN: int => 0;
let TOK_CLOSE_PAREN: int => 0;
let TOK_IF: int => 0;
let TOK_THEN: int => 0;
let TOK_ELSE: int => 0;
let TOK_REC: int => 0;
let TOK_PRO: int => 0;
let TOK_MATCH: int => 0;
let TOK_RETURN: int => 0;
let TOK_STAR: int => 0;
let TOK_MINUS: int => 0;
let TOK_PLUS: int => 0;
let TOK_DIV: int => 0;
let TOK_MODULO: int => 0;
let TOK_LOG_OR: int => 0;
let TOK_LOG_AND: int => 0;
let TOK_BIT_OR: int => 0;
let TOK_BIT_XOR: int => 0;
let TOK_BIT_AND: int => 0;
let TOK_LSSR: int => 0;
let TOK_LSSR_EQ: int => 0;
let TOK_GRTR: int => 0;
let TOK_GRTR_EQ: int => 0;
let TOK_EQUAL: int => 0;
let TOK_DIFF: int => 0;
let TOK_WILDCARD: int => 0;
let TOK_SUB: int => 0;
let TOK_SEMICOL: int => 0;
let TOK_LOOP: int => 0;
let TOK_WHILE: int => 0;
let TOK_DO: int => 0;
let TOK_COUNT: int => 0;


rec token => {
    Type: int,
    Lexeme: string,
    Col: int,
    Line: int,
    Filename: string 
}

let init_types(): void => {
    TOK_IDENTIFIER  => reset_counter();
    TOK_CHR_LIT     => incr_counter();
    TOK_STR_LIT     => incr_counter();
    TOK_NUM_LIT     => incr_counter();
    TOK_LET         => incr_counter();
    TOK_COLON       => incr_counter();
    TOK_COMMA       => incr_counter();
    TOK_SMALL_ARROW => incr_counter();
    TOK_BIG_ARROW   => incr_counter();
    TOK_OPEN_BRACE  => incr_counter();
    TOK_CLOSE_BRACE => incr_counter();
    TOK_OPEN_PAREN  => incr_counter();
    TOK_CLOSE_PAREN => incr_counter();
    TOK_IF          => incr_counter();
    TOK_THEN        => incr_counter();
    TOK_ELSE        => incr_counter();
    TOK_REC         => incr_counter();
    TOK_PRO         => incr_counter();
    TOK_MATCH       => incr_counter();
    TOK_RETURN      => incr_counter();
    TOK_STAR        => incr_counter();
    TOK_MINUS       => incr_counter();
    TOK_PLUS        => incr_counter();
    TOK_DIV         => incr_counter();
    TOK_MODULO      => incr_counter();
    TOK_LOG_OR      => incr_counter();
    TOK_LOG_AND     => incr_counter();
    TOK_BIT_OR      => incr_counter();
    TOK_BIT_XOR     => incr_counter();
    TOK_BIT_AND     => incr_counter();
    TOK_LSSR        => incr_counter();
    TOK_LSSR_EQ     => incr_counter();
    TOK_GRTR        => incr_counter();
    TOK_GRTR_EQ     => incr_counter();
    TOK_EQUAL       => incr_counter();
    TOK_DIFF        => incr_counter();
    TOK_WILDCARD    => incr_counter();
    TOK_SUB         => incr_counter();
    TOK_SEMICOL     => incr_counter();
    TOK_LOOP        => incr_counter();
    TOK_WHILE       => incr_counter();
    TOK_DO          => incr_counter();
    TOK_COUNT       => incr_counter();
}

let lexeme_of_type(type: int): string => {
         if type = TOK_IDENTIFIER  then return "TOK_IDENTIFIER";
    else if type = TOK_CHR_LIT     then return "TOK_CHR_LIT";
    else if type = TOK_STR_LIT     then return "TOK_STR_LIT";
    else if type = TOK_NUM_LIT     then return "TOK_NUM_LIT";
    else if type = TOK_LET         then return "TOK_LET";
    else if type = TOK_COLON       then return "TOK_COLON";
    else if type = TOK_COMMA       then return "TOK_COMMA";
    else if type = TOK_SMALL_ARROW then return "TOK_SMALL_ARROW";
    else if type = TOK_BIG_ARROW   then return "TOK_BIG_ARROW";
    else if type = TOK_OPEN_BRACE  then return "TOK_OPEN_BRACE";
    else if type = TOK_CLOSE_BRACE then return "TOK_CLOSE_BRACE";
    else if type = TOK_OPEN_PAREN  then return "TOK_OPEN_PAREN";
    else if type = TOK_CLOSE_PAREN then return "TOK_CLOSE_PAREN";
    else if type = TOK_IF          then return "TOK_IF";
    else if type = TOK_THEN        then return "TOK_THEN";
    else if type = TOK_ELSE        then return "TOK_ELSE";
    else if type = TOK_REC         then return "TOK_REC";
    else if type = TOK_PRO         then return "TOK_PRO";
    else if type = TOK_MATCH       then return "TOK_MATCH";
    else if type = TOK_RETURN      then return "TOK_RETURN";
    else if type = TOK_STAR        then return "TOK_STAR";
    else if type = TOK_MINUS       then return "TOK_MINUS";
    else if type = TOK_PLUS        then return "TOK_PLUS";
    else if type = TOK_DIV         then return "TOK_DIV";
    else if type = TOK_MODULO      then return "TOK_MODULO";
    else if type = TOK_LOG_OR      then return "TOK_LOG_OR";
    else if type = TOK_LOG_AND     then return "TOK_LOG_AND";
    else if type = TOK_BIT_OR      then return "TOK_BIT_OR";
    else if type = TOK_BIT_XOR     then return "TOK_BIT_XOR";
    else if type = TOK_BIT_AND     then return "TOK_BIT_AND";
    else if type = TOK_LSSR        then return "TOK_LSSR";
    else if type = TOK_LSSR_EQ     then return "TOK_LSSR_EQ";
    else if type = TOK_GRTR        then return "TOK_GRTR";
    else if type = TOK_GRTR_EQ     then return "TOK_GRTR_EQ";
    else if type = TOK_EQUAL       then return "TOK_EQUAL";
    else if type = TOK_DIFF        then return "TOK_DIFF";
    else if type = TOK_WILDCARD    then return "TOK_WILDCARD";
    else if type = TOK_SUB         then return "TOK_SUB";
    else if type = TOK_SEMICOL     then return "TOK_SEMICOL";
    else if type = TOK_LOOP        then return "TOK_LOOP";
    else                                  return "ERROR";
}


let type_of_lexeme(lexeme: string): int => {
    if str_eq(lexeme, "let")                 then return TOK_LET;
    if str_eq(lexeme, ":")                   then return TOK_COLON;
    if str_eq(lexeme, ",")                   then return TOK_COMMA;
    if str_eq(lexeme, "->")                  then return TOK_SMALL_ARROW;
    if str_eq(lexeme, "=>")                  then return TOK_BIG_ARROW;
    if str_eq(lexeme, "{")                   then return TOK_OPEN_BRACE;
    if str_eq(lexeme, "}")                   then return TOK_CLOSE_BRACE;
    if str_eq(lexeme, "(")                   then return TOK_OPEN_PAREN;
    if str_eq(lexeme, ")")                   then return TOK_CLOSE_PAREN;
    if str_eq(lexeme, "if")                  then return TOK_IF;
    if str_eq(lexeme, "then")                then return TOK_THEN;
    if str_eq(lexeme, "else")                then return TOK_ELSE;
    if str_eq(lexeme, "rec")                 then return TOK_REC;
    if str_eq(lexeme, "pro")                 then return TOK_PRO;
    if str_eq(lexeme, "match")               then return TOK_MATCH;
    if str_eq(lexeme, "return")              then return TOK_RETURN;
    if str_eq(lexeme, "*")                   then return TOK_STAR;
    if str_eq(lexeme, "-")                   then return TOK_MINUS;
    if str_eq(lexeme, "+")                   then return TOK_PLUS;
    if str_eq(lexeme, "/")                   then return TOK_DIV;
    if str_eq(lexeme, "%")                   then return TOK_MODULO;
    if str_eq(lexeme, "||")                  then return TOK_LOG_OR;
    if str_eq(lexeme, "&&")                  then return TOK_LOG_AND;
    if str_eq(lexeme, "|")                   then return TOK_BIT_OR;
    if str_eq(lexeme, "^")                   then return TOK_BIT_XOR;
    if str_eq(lexeme, "&")                   then return TOK_BIT_AND;
    if str_eq(lexeme, "<")                   then return TOK_LSSR;
    if str_eq(lexeme, "<=")                  then return TOK_LSSR_EQ;
    if str_eq(lexeme, ">")                   then return TOK_GRTR;
    if str_eq(lexeme, ">=")                  then return TOK_GRTR_EQ;
    if str_eq(lexeme, "=")                   then return TOK_EQUAL;
    if str_eq(lexeme, "!=")                  then return TOK_DIFF;
    if str_eq(lexeme, "_")                   then return TOK_WILDCARD;
    if str_eq(lexeme, "::")                  then return TOK_SUB;
    if str_eq(lexeme, ";")                   then return TOK_SEMICOL;
    if str_eq(lexeme, "loop")                then return TOK_LOOP;
    if str_eq(lexeme, "while")               then return TOK_WHILE;
    if str_eq(lexeme, "do")                  then return TOK_DO;
    return TOK_COUNT;
}

let is_type_keyword(type: int): boolean => {
    if type = TOK_MATCH then return true; 
    if type = TOK_PRO then return true; 
    if type = TOK_REC then return true; 
    if type = TOK_WILDCARD then return true; 
    if type = TOK_RETURN then return true; 
    if type = TOK_SUB then return true; 
    if type = TOK_LET then return true; 
    if type = TOK_IF then return true; 
    if type = TOK_THEN then return true; 
    if type = TOK_ELSE then return true; 
    if type = TOK_LOOP then return true; 
    if type = TOK_WHILE then return true; 
    if type = TOK_DO then return true; 
    return false;
}

let is_type_operator(type: int): boolean => {
    if type = TOK_STAR then return true;
    if type = TOK_MINUS then return true;
    if type = TOK_PLUS then return true;
    if type = TOK_DIV then return true;
    if type = TOK_MODULO then return true;
    if type = TOK_LOG_OR then return true;
    if type = TOK_LOG_AND then return true;
    if type = TOK_BIT_OR then return true;
    if type = TOK_BIT_XOR then return true;
    if type = TOK_BIT_AND then return true;
    if type = TOK_LSSR then return true;
    if type = TOK_LSSR_EQ then return true;
    if type = TOK_GRTR then return true;
    if type = TOK_GRTR_EQ then return true;
    if type = TOK_EQUAL then return true;
    if type = TOK_DIFF then return true;
    return false;

}

let is_lexeme_keyword(s: string):boolean => {
    return is_type_keyword(type_of_lexeme(s));
}


//-----------------------------------------------------------------------------



//-----------------------------------------------------------------------------
// TOKEN LIST FUNCTIONS
//-----------------------------------------------------------------------------
rec token_list => {
    Head: token,
    Tail: token_list
}


let append_token(l: token_list, t: token): token_list => {
    let res : token_list => {
        Head => t,
        Tail => l
    };
    return res;
}


let get_nth_token_aux(l: token_list, n: int): token => {
    if l = NULL then {
        print("Index out of range: Cannot access token !\n");
        exit(1);
    }
    if n = 0 then return l::Head;
    return get_nth_token_aux(l::Tail, n-1);
}


let get_list_length(l: token_list): int => {
    if l = NULL then return 0;
    return 1 + get_list_length(l::Tail);
}

let get_nth_token(l: token_list, n: int) : token => {
    return get_nth_token_aux(l, get_list_length(l) - n - 1);
}

let print_list_types(l: token_list) : void => {
    let len: int => get_list_length(l);
    loop i: 0 -> len-1 => {
        let tok: token => get_nth_token(l, i);
        print("-> ");
        print(lexeme_of_type(tok::Type));
        print(": '");
        print(tok::Lexeme);
        print("'\n");
    }
}
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// LEXER FUNCTIONS
//-----------------------------------------------------------------------------


rec lexer => {
    Data: string,
    Cursor: int,
    Col: int,
    Line: int,
    Filename: string,
    Toks: token_list
}


let new_lexer(filename: string): lexer => {
    let data: string => read_file(filename);
    let res: lexer => {
        Data => data,
        Cursor => 0,
        Col => 1,
        Line => 1,
        Filename => filename,
        Toks => NULL
    }; return res;
}


let lexer_peek(l: lexer): char => {


    if l::Cursor < get_string_length(l::Data) then 
        return get_nth_char(l::Data, l::Cursor);
    return 0;
}


let lexer_consume(l: lexer): void => {
    let c: char => lexer_peek(l);
    l::Cursor => l::Cursor+1;
    if c = '\n' then {
        l::Col => 1;
        l::Line => l::Line + 1;
    }
    else if c != 0 then 
        l::Col => l::Col + 1;
}

let length_until_next_delimeter(l: lexer): int => {
    let i: int => 0;
    let cursor: int => l::Cursor;
    while is_delimeter(lexer_peek(l)) = false do {
        i => i + 1;
        lexer_consume(l);
    }
    l::Cursor => cursor;
    return i;
}

let length_of_delimeter(l: lexer): int => {
    let c1: char => lexer_peek(l);
    l::Cursor => l::Cursor + 1;
    let c2: char => lexer_peek(l);
    l::Cursor => l::Cursor - 1;
    let s: string => "";
    s => append_string(s, c1);
    s => append_string(s, c2);
    if str_eq(s, "->") then return 2;
    if str_eq(s, "=>") then return 2;
    if str_eq(s, "&&") then return 2;
    if str_eq(s, "||") then return 2;
    if str_eq(s, ">=") then return 2;
    if str_eq(s, "<=") then return 2;
    if str_eq(s, "!=") then return 2;
    if str_eq(s, "::") then return 2;
    if c1 = ':' then return 1;
    if c1 = ',' then return 1;
    if c1 = '/' then return 1;
    if c1 = '%' then return 1;
    if c1 = '*' then return 1;
    if c1 = '+' then return 1; 
    if c1 = '-' then return 1;
    if c1 = '^' then return 1;
    if c1 = '{' then return 1;
    if c1 = '}' then return 1;
    if c1 = '(' then return 1; 
    if c1 = ')' then return 1;
    if c1 = '=' then return 1;
    if c1 = '<' then return 1;
    if c1 = '>' then return 1;
    if c1 = ';' then return 1;  
    return 0;
}

let is_char_num(c: char): boolean => {
    return c <= '9' && c >= '0';
}

let length_of_num_lit(l: lexer): int  => {
    let cur: int => l::Cursor;
    let cter:int  => 0;
    while is_char_num(lexer_peek(l)) do {
        l::Cursor => l::Cursor + 1;
        cter => cter + 1;
    }
    l::Cursor => cur;
    return cter;
}


let length_of_delimited_literal(l: lexer, c: char): int => {
    let cursor: int => l::Cursor;
    let c1: char => lexer_peek(l);
    if c1 != c then return 0;
    l::Cursor => l::Cursor + 1;
    let pass: boolean => false;
    while lexer_peek(l) != c || pass do {
        if pass then pass => false;
        else if lexer_peek(l) = '\\' then pass => true;
        l::Cursor => l::Cursor+1;
    }
    let res: int => l::Cursor - cursor + 1;
    l::Cursor => cursor;
    return res;
}

let COM_SINGLE: int => 0;
let COM_MULTI: int => 0;

let init_comment_type(): void => {
    COM_SINGLE => set_counter(1);
    COM_MULTI => incr_counter();
}

let is_comment(l: lexer): int => {
    let cursor: int => l::Cursor;
    let c: char => lexer_peek(l);
    if c != '/' then return 0;
    l::Cursor => l::Cursor + 1;
    c => lexer_peek(l);
    if c = '/' then {
        l::Cursor => cursor;
        return COM_SINGLE;
    }
    if c = '*' then {
        l::Cursor => cursor;
        return COM_MULTI;
    }
    l::Cursor => cursor;
    return 0;
}

let is_end_comment(l: lexer, type: int): boolean => {
    if type = 0 then return 0;
    if type = COM_SINGLE then return lexer_peek(l) = '\n';
    let s: string => "";
    append_string(s, lexer_peek(l));
    l::Cursor => l::Cursor + 1;
    append_string(s, lexer_peek(l));
    let res: boolean => str_eq(s, "*/");
    l::Cursor => l::Cursor - 1;
    return res;
}

let lexer_consume_n(l: lexer, n: int): void => {
    loop i: 1 -> n => {
        lexer_consume(l);
    }
}


let create_lexeme(l: lexer, length: int): string => {
    return create_string(l::Data, l::Cursor, length);
}

let step_lexer(l: lexer): void => {
    let res: token => {
        Filename => l::Filename,
        Col => l::Col,
        Line => l::Line,
    };
    while is_comment(l) || is_whitespace(lexer_peek(l)) do {
        let com_type: int => is_comment(l);
        if com_type then {
            lexer_consume_n(l, 2);
            while is_end_comment(l, com_type) = false do
                lexer_consume(l);
            if com_type = COM_MULTI then
                lexer_consume(l);
            lexer_consume(l);
        }
        while is_whitespace(lexer_peek(l)) do lexer_consume(l);
    }
    if lexer_peek(l) = 0 then return;
    res::Col => l::Col;
    res::Line => l::Line;
    if is_char_num(lexer_peek(l)) then {
        let length: int => length_of_num_lit(l);
        res::Lexeme => create_lexeme(l, length);
        res::Type => TOK_NUM_LIT;
        lexer_consume_n(l, length);
    }
    else if lexer_peek(l) = '\'' then {
        let length: int => length_of_delimited_literal(l, '\'');
        res::Lexeme => create_lexeme(l, length);
        res::Type => TOK_CHR_LIT;
        lexer_consume_n(l, length);
    }
    else if lexer_peek(l) = '\"' then {
        let length: int => length_of_delimited_literal(l, '\"');
        res::Lexeme => create_lexeme(l, length);
        res::Type => TOK_STR_LIT;
        lexer_consume_n(l, length);
    }
    else if is_delimeter(lexer_peek(l)) then {
        let length: int => length_of_delimeter(l);
        res::Lexeme => create_lexeme(l, length);
        res::Type => type_of_lexeme(res::Lexeme);
        lexer_consume_n(l, length);
    }
    else {
        let length: int => length_until_next_delimeter(l);
        res::Lexeme => create_lexeme(l, length);
        if is_lexeme_keyword(res::Lexeme) then
            res::Type => type_of_lexeme(res::Lexeme);
        else
            res::Type => TOK_IDENTIFIER;
        lexer_consume_n(l, length);
    }
    l::Toks => append_token(l::Toks, res);
}

let lex_program(l: lexer): void => {
    while lexer_peek(l) do
        step_lexer(l);
}

//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// UTILS FUNCTIONS
//-----------------------------------------------------------------------------

let implemented(s: string): void => {
    print("TODO: ");
    print(s);
    print(" is not yet implemented\n");
    exit(1);
}


let compiler_assert(b: boolean): void => {
    if b = 0 then {
        print("Assertion failed\n");
        exit(1);
    }
}

let print_int(n: int): void => {
  let a: int => n / 10;
  if a then print_int(a);
  putchar(n%10 + '0');
}


let create_string(src: string, offset: int,  length: int): string => {
    let res: string => "";
    loop i: 0 -> length - 1 => {
        let c: char => get_nth_char(src, offset + i);
        res => append_string(res, c);
    }
    return res;
}

let is_whitespace(c: char): boolean => {
    if c = ' ' then return true;
    if c = '\n' then return true;
    if c = '\t' then return true;
    return false;
}


let is_delimeter(c: char): boolean => {
    let delimeters: string => "><;,:-+*/%&|!=(){}^ \n\'\"0123456789";
    let len: int => get_string_length(delimeters);
    loop i: 0 -> len - 1 => {
        if get_nth_char(delimeters, i) = c then 
            return true;
    }
    return false;
}

//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// FILE HANDLING
//-----------------------------------------------------------------------------

rec file => {
    Filename: string,
    Data: string,
    Mode: int,
}

let READ_MODE: int => 0;
let WRITE_MODE: int => 0;
let CLOSED: int => 0;

let init_file_modes(): void => {
    READ_MODE => reset_counter();
    WRITE_MODE => incr_counter();
    CLOSED => incr_counter();

}

let open_file(filename: string, mode: int): file => {
    let res: file => {
        Filename => filename,
        Data => "",
        Mode => mode
    }; 
    if mode = READ_MODE then  
        res::Data => read_file(filename);
    else if mode != WRITE_MODE then
    {
        print("Could not open file \'");
        print(filename);
        print("\': Invalid mode specified\n");
        exit(1);
    }
    return res;
}

let close_file(f: file): void => {
    write_string_to_file(f::Data, f::Filename);
    f::Data => "";
    f::Filename => "";
}

let print_to_file(f: file, s: string): void => {
    f::Data => concat_string(f::Data, s);
}
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// MAIN FUNCTION
//-----------------------------------------------------------------------------

let init(): void => {
    init_types();
    init_file_modes();
    init_comment_type();
}


let main(): int => {
    init();
    let l: lexer => new_lexer("RockerSRC/compiler.rkr");
    lex_program(l);
    // print_list_types(l::Toks);
    return 0;
}

//-----------------------------------------------------------------------------
