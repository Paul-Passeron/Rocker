let counter: int => 0;

let incr_counter(): int => {
    counter => counter + 1;
    return counter;
}

let reset_counter(): int => {
    counter => 0;
    return counter;
}


let TOK_IDENTIFIER: int => 0;
let TOK_CHR_LIT: int => 0;
let TOK_STR_LIT: int => 0;
let TOK_NUM_LIT: int => 0;
let TOK_LET: int => 0;
let TOK_COLON: int => 0;
let TOK_COMMA: int => 0;
let TOK_SMALL_ARROW: int => 0;
let TOK_BIG_ARROW: int => 0;
let TOK_OPEN_BRACE: int => 0;
let TOK_CLOSE_BRACE: int => 0;
let TOK_OPEN_PAREN: int => 0;
let TOK_CLOSE_PAREN: int => 0;
let TOK_IF: int => 0;
let TOK_THEN: int => 0;
let TOK_ELSE: int => 0;
let TOK_REC: int => 0;
let TOK_PRO: int => 0;
let TOK_MATCH: int => 0;
let TOK_RETURN: int => 0;
let TOK_STAR: int => 0;
let TOK_MINUS: int => 0;
let TOK_PLUS: int => 0;
let TOK_DIV: int => 0;
let TOK_MODULO: int => 0;
let TOK_LOG_OR: int => 0;
let TOK_LOG_AND: int => 0;
let TOK_BIT_OR: int => 0;
let TOK_BIT_XOR: int => 0;
let TOK_BIT_AND: int => 0;
let TOK_LSSR: int => 0;
let TOK_LSSR_EQ: int => 0;
let TOK_GRTR: int => 0;
let TOK_GRTR_EQ: int => 0;
let TOK_EQUAL: int => 0;
let TOK_DIFF: int => 0;
let TOK_WILDCARD: int => 0;
let TOK_SUB: int => 0;
let TOK_SEMICOL: int => 0;
let TOK_LOOP: int => 0;
let TOK_COUNT: int => 0;


rec token => {
    Type: int,
    Lexeme: string,
    Col: int,
    Line: int,
    Filename: string 
}

let init_types(): void => {
    TOK_IDENTIFIER => reset_counter();
    TOK_CHR_LIT => incr_counter();
    TOK_STR_LIT => incr_counter();
    TOK_NUM_LIT => incr_counter();
    TOK_LET => incr_counter();
    TOK_COLON => incr_counter();
    TOK_COMMA => incr_counter();
    TOK_SMALL_ARROW => incr_counter();
    TOK_BIG_ARROW => incr_counter();
    TOK_OPEN_BRACE => incr_counter();
    TOK_CLOSE_BRACE => incr_counter();
    TOK_OPEN_PAREN => incr_counter();
    TOK_CLOSE_PAREN => incr_counter();
    TOK_IF => incr_counter();
    TOK_THEN => incr_counter();
    TOK_ELSE => incr_counter();
    TOK_REC => incr_counter();
    TOK_PRO => incr_counter();
    TOK_MATCH => incr_counter();
    TOK_RETURN => incr_counter();
    TOK_STAR => incr_counter();
    TOK_MINUS => incr_counter();
    TOK_PLUS => incr_counter();
    TOK_DIV => incr_counter();
    TOK_MODULO => incr_counter();
    TOK_LOG_OR => incr_counter();
    TOK_LOG_AND => incr_counter();
    TOK_BIT_OR => incr_counter();
    TOK_BIT_XOR => incr_counter();
    TOK_BIT_AND => incr_counter();
    TOK_LSSR => incr_counter();
    TOK_LSSR_EQ => incr_counter();
    TOK_GRTR => incr_counter();
    TOK_GRTR_EQ => incr_counter();
    TOK_EQUAL => incr_counter();
    TOK_DIFF => incr_counter();
    TOK_WILDCARD => incr_counter();
    TOK_SUB => incr_counter();
    TOK_SEMICOL => incr_counter();
    TOK_LOOP => incr_counter();
    TOK_COUNT => incr_counter();
}


let lexeme_of_type(type: int): string => {
         if (type = TOK_IDENTIFIER)  then return "TOK_IDENTIFIER";
    else if (type = TOK_CHR_LIT)     then return "TOK_CHR_LIT";
    else if (type = TOK_STR_LIT)     then return "TOK_STR_LIT";
    else if (type = TOK_NUM_LIT)     then return "TOK_NUM_LIT";
    else if (type = TOK_LET)         then return "TOK_LET";
    else if (type = TOK_COLON)       then return "TOK_COLON";
    else if (type = TOK_COMMA)       then return "TOK_COMMA";
    else if (type = TOK_SMALL_ARROW) then return "TOK_SMALL_ARROW";
    else if (type = TOK_BIG_ARROW)   then return "TOK_BIG_ARROW";
    else if (type = TOK_OPEN_BRACE)  then return "TOK_OPEN_BRACE";
    else if (type = TOK_CLOSE_BRACE) then return "TOK_CLOSE_BRACE";
    else if (type = TOK_OPEN_PAREN)  then return "TOK_OPEN_PAREN";
    else if (type = TOK_CLOSE_PAREN) then return "TOK_CLOSE_PAREN";
    else if (type = TOK_IF)          then return "TOK_IF";
    else if (type = TOK_THEN)        then return "TOK_THEN";
    else if (type = TOK_ELSE)        then return "TOK_ELSE";
    else if (type = TOK_REC)         then return "TOK_REC";
    else if (type = TOK_PRO)         then return "TOK_PRO";
    else if (type = TOK_MATCH)       then return "TOK_MATCH";
    else if (type = TOK_RETURN)      then return "TOK_RETURN";
    else if (type = TOK_STAR)        then return "TOK_STAR";
    else if (type = TOK_MINUS)       then return "TOK_MINUS";
    else if (type = TOK_PLUS)        then return "TOK_PLUS";
    else if (type = TOK_DIV)         then return "TOK_DIV";
    else if (type = TOK_MODULO)      then return "TOK_MODULO";
    else if (type = TOK_LOG_OR)      then return "TOK_LOG_OR";
    else if (type = TOK_LOG_AND)     then return "TOK_LOG_AND";
    else if (type = TOK_BIT_OR)      then return "TOK_BIT_OR";
    else if (type = TOK_BIT_XOR)     then return "TOK_BIT_XOR";
    else if (type = TOK_BIT_AND)     then return "TOK_BIT_AND";
    else if (type = TOK_LSSR)        then return "TOK_LSSR";
    else if (type = TOK_LSSR_EQ)     then return "TOK_LSSR_EQ";
    else if (type = TOK_GRTR)        then return "TOK_GRTR";
    else if (type = TOK_GRTR_EQ)     then return "TOK_GRTR_EQ";
    else if (type = TOK_EQUAL)       then return "TOK_EQUAL";
    else if (type = TOK_DIFF)        then return "TOK_DIFF";
    else if (type = TOK_WILDCARD)    then return "TOK_WILDCARD";
    else if (type = TOK_SUB)         then return "TOK_SUB";
    else if (type = TOK_SEMICOL)     then return "TOK_SEMICOL";
    else if (type = TOK_LOOP)        then return "TOK_LOOP";
    else                                  return "ERROR";
}


rec token_list => {
    Head: token,
    Tail: token_list
}


let append_token(l: token_list, t: token): token_list => {
    let res : token_list => {
        Head => t,
        Tail => l
    };
    return res;
}


let get_nth_token_aux(l: token_list, n: int): token => {
    if l = NULL then {
        print("Index out of range: Cannot access token !\n");
        exit(1);
    }
    if n = 0 then return l::Head;
    return get_nth_token_aux(l::Tail, n-1);
}


let get_list_length(l: token_list): int => {
    if l = NULL then return 0;
    return 1 + get_list_length(l::Tail);
}

let get_nth_token(l: token_list, n: int) : token => {
    return get_nth_token_aux(l, get_list_length(l) - n - 1);
}

let empty_tok(t: int): token => {
    let res: token => {
        Type => t,
        Lexeme => "",
        Col => 0,
        Line => 0,
        Filename => "" 
    };
    return res;
}

let print_list_types(l: token_list) : void => {
    let len: int => get_list_length(l);
    loop i: 0 -> len-1 => {
        let tok: token => get_nth_token(l, i);
        print("-> ");
        print(lexeme_of_type(tok::Type));
        print("\n");
    }
}


rec lexer => {
    Data: string,
    Cursor: int,
    Col: int,
    Line: int,
    Filename: string,
    Toks: token_list
}


let new_lexer(filename: string): lexer => {
    let data: string => read_file(filename);
    let res: lexer => {
        Data => data,
        Cursor => 0,
        Col => 1,
        Line => 1,
        Filename => filename,
        Toks => NULL
    }; return res;
}


let compiler_assert(b: boolean): void => {
    if b = 0 then {
        print("Assertion failed\n");
        exit(1);
    }
}

let create_lexeme(src: string, offset: int,  length: int): string => {
    let res: string => "";
    loop i: 0 -> length - 1 => {
        let c: char => get_nth_char(src, offset + i);
        res => append_string(res, c);
    }
    return res;
}



let main(): int => {
    init_types();
    let l: lexer => new_lexer("examples/fact.rkr");

    return 0;
}

