pro token_type_t => {
  Cons1 : int,
  Cons2 : string,
  Cons3 : void,
}

rec token_t => {
  Lexeme   : string,
  Type     : token_type_t,
  Col      : int,
  Line     : int,
  Filename : string ,
}


rec list_t(t) => {
 Cons : (t * list_t(t)),
}

let func(a : int, b : token_type_t, c : string) : int => {
  print(c);
  match b => {
    -> token_type_t::Cons1::n => print_int(n);
    -> token_type_t::Cons2::s => print(s);
    -> token_type_t::Cons3 => print("This constructor is empty !");
  }
  let variable : int => a + 3;
  print_int(variable);
  let global t : token_t;
  t::Lexeme => "let";
  t::Type => Cons1::(12);
}

// every function that returns a user defined type returns a pointer
// to it that is allocated via scope
// if the let statement is global, we actually copy the content
// of the returned pointer in a newly persistent allocated pointer
// Semantically, those two programs would be exactly the same
//
// -> let tmp : my_type => returns_a_user_define_type(...);
//    let global my_pointer : my_type => tmp;
//  
// -> let global my_pointer : my_type => returns_a_user_define_type(...);


// Later when everyrhing pretty much works, we'll maybe implement
// some user-defined types that are non-recursive as values 
// directly instead of pointers


// variables are mutable