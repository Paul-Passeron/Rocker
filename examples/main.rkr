/* This is a 
multi line
comment */

// Comments are C-style comments !



// main is the entry point of the program
let main : void -> int  => {
    let () => printf "Hello, World !\n" in
    0
}

let fact n : int -> int => {
    if n <= 1 then 1
    else n * fact (n-1)
}

// every let expression is basically the same,
// it binds an identifier or nothing ('let ()')
// (let's called them vals) to a function

// There is no difference between functions and 
// values

// A value is simply a function that doesn't take any input
// ('void -> 'a'  where 'a is an arbitrary type)

// Type annotation could be mendatory for every let expression


// How scope work:

/*

let a : 'a => ...

let b : 'b => 
    {
    let a : 'c => {...}
    ...
    }
    ^
    | This is legal, it creates another val a in the current
    scope, making the previous a unreachable in the current 
    But it still exists

/*


let func2args a b : 'a -> 'b -> 'c => {
    ...
}


// Every val can be accessed from anywhere within the scope
// in which it has been declared
// This means every function can be recursive
// And every val can be mutually recursive with any
// other val


// type definition syntax:


pro product_type_t => {
    Constructor1 : 'a -> 'b,
    Constructor2 : 'c,
    ...
}

rec record_type_t =>
{
    Field1: 'a,
    Field2: 'b->'c,
    ...
}



// match expression example

match a => {
    -> Constructor value : {
        ...
    } 
    -> case1: 0
    -> case2: ...
}

// This is a pure functionnal language; you cannot
// reassing values that are already binded after a let
// The only way you can do that is when the two values
// are not in the same immediate scope (cf 'How scope work')



// how value calling works (basically function calling)

// Values are curriffied functions / values:

let a : 'a => call_value

let b : 'b => call_function1arg argument

let i_think_this_is_cool : 'c =>
    call_func 
        {
            // ... some processing to get the arg
            arg
        }
        (arg2)
        (arg3)
